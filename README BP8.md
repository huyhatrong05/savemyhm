1) Вариант8  Реализуйте рекурсивную функцию для подсчета суммы элементов массива
2) ОПИСАНИЕ АЛГОРИТМА С СИНТАКСИСОМ
1 Основной принцип рекурсии
Большую задачу разбиваем на мелкие одинаковые подзадачи
Каждая следующая подзадача проще предыдущей
Должно быть условие остановки
2 Базовый случай (условие выхода из рекурсии)
Если массив пустой - сумма равна 0
Это точка остановки, чтобы функция не вызывала себя бесконечно
3 Рекурсивный случай (шаг разбиения)
Сумма всего массива = первый элемент + сумма оставшейся части массива
Оставшуюся часть массива обрабатываем той же функцией
4 Процесс вычисления на примере [3, 1, 2]
Шаг 1: Сумма([3,1,2]) = 3 + Сумма([1,2])
Шаг 2: Сумма([1,2]) = 1 + Сумма([2])
Шаг 3: Сумма([2]) = 2 + Сумма([])
Шаг 4: Сумма([]) = 0 (базовый случай)
5 Процесс сборки результата
Из шага 3: 2 + 0 = 2
Из шага 2: 1 + 2 = 3
Из шага 1: 3 + 3 = 6
6 Ключевые особенности
Функция вызывает саму себя
Каждый вызов работает с уменьшенной версией задачи
Решение собирается из частей снизу вверх
3) ОПИСАНИЕ СЛОЖНОСТИ
Алгоритм выполняет один рекурсивный вызов для каждого элемента массива, для массива размером n функция вызывается ровно n раз
Каждый вызов выполняет константное количество операций - проверку условия и сложение
Несмотря на теоретическую сложность O(n), алгоритм может столкнуться с ограничениями глубины рекурсии
Для очень больших массивов возможна ошибка переполнения стека вызовов
На практике для больших данных лучше использовать итеративные методы
Это сохраняет сложность O(n) но уменьшает затраты памяти
4) ОПИСАНИЕ ВРЕМЕННОЙ СЛОЖНОСТИ
O(n), где n - количество элементов в массиве, так как алгоритм выполняет ровно n рекурсивных вызовов, каждый из которых работает за константное время.
Алгоритм выполняет ровно n рекурсивных вызовов для массива из n элементов, где каждый вызов выполняет константное количество операций (проверка условия, доступ к элементу, сложение), что в совокупности дает линейную зависимость от размера входных данных.
5) КАКОВА ВРЕМЕННАЯ СЛОЖНОСТЬ ЗАДАЧИ О N ФЕРЗЯХ?
В задаче о расстановке n ферзей на доске n×n алгоритм перебирает все возможные перестановки позиций. Для первого ферзя есть n вариантов, для второго - (n-1) вариантов, для третьего - (n-2) и так далее. Общее количество проверяемых конфигураций составляет n × (n-1) × (n-2) × ... × 1 = n! (факториал n).

