1. Блочная (корзинная) сортировка (Bucket Sort)
1. Определение алгоритма
Блочная сортировка — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. Каждая корзина сортируется отдельно (например, сортировкой вставками), после чего отсортированные корзины объединяются в один массив.

2. Пример кода (Python)
def bucket_sort(arr):
    # 1. Создаём пустые корзины
    num_buckets = len(arr)
    buckets = [[] for _ in range(num_buckets)]
    
    # 2. Распределяем элементы по корзинам
    for num in arr:
        index = int(num * num_buckets)  # Для чисел в диапазоне [0, 1)
        buckets[index].append(num)
    
    # 3. Сортируем каждую корзину
    for bucket in buckets:
        bucket.sort()
    
    # 4. Объединяем корзины в исходный массив
    k = 0
    for bucket in buckets:
        for num in bucket:
            arr[k] = num
            k += 1
    return arr

# Пример использования
arr = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
print("Исходный массив:", arr)
print("Отсортированный массив:", bucket_sort(arr))
3. Результаты работы в консоли
Исходный массив: [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
Отсортированный массив: [0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]4. Объяснение работы алгоритма
Создание корзин: buckets = [[] for _ in range(num_buckets)]

Распределение: index = int(num * num_buckets) — определяем номер корзины для каждого числа.

Сортировка корзин: bucket.sort() — каждая корзина сортируется отдельно.

Объединение: вложенные циклы собирают отсортированные элементы обратно в массив.

5. Оценка временной сложности
O(n + k), где k — количество корзин.

Объяснение  временной сложности
Распределение по корзинам: O(n)

Сортировка каждой корзины: в среднем O(n) при равномерном распределении

Слияние: O(n)

Итог: O(n + k), в лучшем случае — почти O(n).

2. Блинная сортировка (Pancake Sort)
1. Определение алгоритма
Блинная сортировка — это алгоритм, основанный на операции переворота префикса массива. Алгоритм находит максимальный элемент в неотсортированной части, переворачивает массив до его позиции, чтобы он оказался в начале, а затем переворачивает всю неотсортированную часть, чтобы он оказался на своём месте.

2. Пример кода (Python)
def pancake_sort(arr):
    n = len(arr)
    for i in range(n, 0, -1):
        # Находим индекс максимального элемента в неотсортированной части
        max_index = arr.index(max(arr[:i]))
        
        # Если максимум не на своём месте, переворачиваем
        if max_index != i - 1:
            # Переворачиваем до максимума
            arr = arr[:max_index+1][::-1] + arr[max_index+1:]
            # Переворачиваем всю неотсортированную часть
            arr = arr[:i][::-1] + arr[i:]
    return arr

# Пример использования
arr = [3, 1, 4, 2, 5]
print("Исходный массив:", arr)
print("Отсортированный массив:", pancake_sort(arr))
3. Результаты работы в консоли
Исходный массив: [3, 1, 4, 2, 5]
Отсортированный массив: [1, 2, 3, 4, 5]
4. Объяснение работы алгоритма
Поиск максимума: max_index = arr.index(max(arr[:i]))

Первый переворот: arr[:max_index+1][::-1] — перемещаем максимум в начало.

Второй переворот: arr[:i][::-1] — перемещаем максимум в конец неотсортированной части.

5. Оценка временной сложности
O(n²)

 Объяснение  временной сложности
Поиск максимума: O(n)

Два переворота: O(n)

Всего шагов: n

Итог: O(n²)

3. Сортировка бусинами (Bead Sort)
1. Определение алгоритма
Сортировка бусинами моделирует падение бусин под действием гравиации. Каждое число представляется как ряд бусин, которые падают вниз, образуя отсортированные столбцы.

2. Пример кода (Python)
def bead_sort(arr):
    # Определяем максимальное значение
    max_val = max(arr)
    
    # Создаём матрицу бусин
    beads = [[0] * max_val for _ in range(len(arr))]
    
    # Расставляем бусины
    for i, num in enumerate(arr):
        for j in range(num):
            beads[i][j] = 1
    
    # Гравитация: бусины падают вниз
    for j in range(max_val):
        sum_col = sum(beads[i][j] for i in range(len(arr)))
        for i in range(len(arr)):
            beads[i][j] = 1 if i < sum_col else 0
    
    # Считываем отсортированные значения
    for i in range(len(arr)):
        arr[i] = sum(beads[i])
    
    return arr

# Пример использования
arr = [3, 1, 4, 2]
print("Исходный массив:", arr)
print("Отсортированный массив:", bead_sort(arr))
3. Результаты работы в консоли
Исходный массив: [3, 1, 4, 2]
Отсортированный массив: [1, 2, 3, 4]
4. Объяснение работы алгоритма
Инициализация бусин: beads = [[0] * max_val for _ in range(len(arr))]

Расстановка: beads[i][j] = 1 — ставим бусины согласно значениям.

Гравитация: подсчитываем сумму столбца и «сбрасываем» бусины вниз.

Считывание: arr[i] = sum(beads[i]) — преобразуем бусины обратно в числа.

5. Оценка временной сложности
O(n + S), где S — сумма всех элементов.

Объяснение  временной сложности
Расстановка бусин: O(n * m)

Гравитация: O(n * m)

Итог: O(n * m), но на практике зависит от диапазона значений.

4. Поиск скачками (Jump Search)
1. Определение алгоритма
Поиск скачками — это алгоритм для отсортированных массивов, который «прыгает» через фиксированное количество элементов, чтобы быстро сузить диапазон поиска, после чего выполняет линейный поиск внутри найденного блока.

2. Пример кода (Python)
import math

def jump_search(arr, x):
    n = len(arr)
    step = int(math.sqrt(n))
    prev = 0
    
    # Прыжки вперёд
    while arr[min(step, n) - 1] < x:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1
    
    # Линейный поиск в блоке
    for i in range(prev, min(step, n)):
        if arr[i] == x:
            return i
    return -1

# Пример использования
arr = [1, 3, 5, 7, 9, 11, 13]
x = 7
print(f"Индекс элемента {x}:", jump_search(arr, x))
3. Результаты работы в консоли
Индекс элемента 7: 3
4. Объяснение работы алгоритма
Прыжки: step += int(math.sqrt(n)) — прыгаем вперёд на √n.

Линейный поиск: for i in range(prev, min(step, n)) — ищем в найденном блоке.

5. Оценка временной сложности
O(√n)

Объяснение  временной сложности
Количество прыжков: O(√n)

Линейный поиск в блоке: O(√n)

Итог: O(√n)

5. Экспоненциальный поиск (Exponential Search)
1. Определение алгоритма
Экспоненциальный поиск сочетает последовательное увеличение диапазона (в степени двойки) с последующим бинарным поиском в найденном диапазоне.

2. Пример кода (Python)
def exponential_search(arr, x):
    if arr[0] == x:
        return 0
    
    n = len(arr)
    i = 1
    # Экспоненциальное увеличение диапазона
    while i < n and arr[i] <= x:
        i *= 2
    
    # Бинарный поиск в диапазоне [i/2, min(i, n)]
    low = i // 2
    high = min(i, n - 1)
    
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1

# Пример использования
arr = [1, 3, 5, 7, 9, 11, 13]
x = 9
print(f"Индекс элемента {x}:", exponential_search(arr, x))
3. Результаты работы в консоли
Индекс элемента 9: 4 
4. Объяснение работы алгоритма
Экспоненциальное расширение: i *= 2 — увеличиваем диапазон.

Бинарный поиск: стандартный двоичный поиск в диапазоне [i/2, min(i, n)].

5. Оценка временной сложности
O(log n)

Объяснение  временной сложности
Нахождение диапазона: O(log n)

Бинарный поиск: O(log n)

Итог: O(log n)

Тернарный поиск (Ternary Search)
1. Определение алгоритма
Тернарный поиск делит отсортированный массив на три части и рекурсивно сужает область поиска, сравнивая искомое значение с двумя внутренними точками.

2. Пример кода (Python)
def ternary_search(arr, l, r, x):
    if r >= l:
        mid1 = l + (r - l) // 3
        mid2 = r - (r - l) // 3
        
        if arr[mid1] == x:
            return mid1
        if arr[mid2] == x:
            return mid2
        
        if x < arr[mid1]:
            return ternary_search(arr, l, mid1 - 1, x)
        elif x > arr[mid2]:
            return ternary_search(arr, mid2 + 1, r, x)
        else:
            return ternary_search(arr, mid1 + 1, mid2 - 1, x)
    return -1

# Пример использования
arr = [1, 3, 5, 7, 9, 11, 13]
x = 11
print(f"Индекс элемента {x}:", ternary_search(arr, 0, len(arr) - 1, x))
3. Результаты работы в консоли
Индекс элемента 11: 5
4. Объяснение работы алгоритма
Делим на три части: mid1 = l + (r - l) // 3, mid2 = r - (r - l) // 3

Сравниваем с mid1 и mid2

Рекурсивно сужаем диапазон в одной из трёх частей.

5. Оценка временной сложности
O(log₃ n)

Объяснение  временной сложности
На каждом шаге диапазон уменьшается в 3 раза

Количество шагов: log₃ n

Итог: O(log n), но с большей константой, чем у бинарного поиска
